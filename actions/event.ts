"use server";

/**
 * This file contains db actions for the event table
 */

import { GDSCEvent as GDSCEventPrisma } from "@prisma/client";
import { EVENT_TYPES } from "@/types/gdsc-event";
import { db } from "@/lib/db";
import { auth } from "@clerk/nextjs/server";
import { EventSchema } from "@/schemas";
import * as z from "zod";

export async function getEvents(): Promise<GDSCEventPrisma[]> {
  return db.gDSCEvent.findMany();
}

export async function getEvent(
  id: GDSCEventPrisma["id"]
): Promise<GDSCEventPrisma | null> {
  return db.gDSCEvent.findUnique({ where: { id } });
}

export async function createEvent(values: FormData) {
  const user = auth();

  if (!user || !user.userId) {
    return { error: "Unauthorized. Please login to create an event." };
  }

  if (user.sessionClaims?.metadata.role !== "ADMIN") {
    return { error: "Unauthorized. Only admins can create events." };
  }

  const imageCount: number = +(values.get("imageCount") as string) || 0;
  const aboutImages: File[] = [];

  for (let image = 0; image < imageCount; image++) {
    aboutImages.push(values.get(`aboutImages[${image}]`) as File);
  }

  // Getting the parsed values from the form to validate it.
  // For those confused, we always validate the schema client AND server side
  const parsedValues: z.infer<typeof EventSchema> = {
    eventName: values.get("eventName") as string,
    type: values.get("type") as (typeof EVENT_TYPES)[number],
    room: values.get("room") as string,
    startTime: values.get("startTime") as string,
    endTime: values.get("endTime") as string,
    date: new Date(values.get("date") as string),
    location: values.get("location") as string,
    description: values.get("description") as string,
    githubRepo: values.get("githubRepo") as string,
    slidesURL: values.get("slidesURL") as string,
    organizerIds: JSON.parse(values.get("organizerIds") as any) as string[],
    about: {
      body: JSON.parse(values.get("aboutBody") as string),
      images: aboutImages,
    },
    imageSrc: values.get("imageSrc") as File,
  };

  // Convert files to buffer since mongodb can't save File types
  let mainImageBuffer: Buffer | null = null;
  let extraImagesBuffer: Buffer[] = [];
  if (parsedValues.imageSrc) {
    mainImageBuffer = Buffer.from(await parsedValues.imageSrc.arrayBuffer());
  }
  if (parsedValues.about?.images) {
    extraImagesBuffer = await Promise.all(
      parsedValues.about?.images.map(async (image) =>
        Buffer.from(await image.arrayBuffer())
      )
    );
  }

  // Validate the parsed values, all used values after should be from validatedFields
  const validatedFields = EventSchema.safeParse(parsedValues);
  if (!validatedFields.success) {
    return { error: validatedFields.error.errors[0].message };
  }

  const createdAtDate = new Date();

  // Using partial to ignore ID since it will be auto generated by mongoDB
  const newGDSCEvent: Required<Partial<Omit<GDSCEventPrisma, "id">>> = {
    name: validatedFields.data.eventName,
    type: validatedFields.data.type || "other",
    room: validatedFields.data.room,
    tags: validatedFields.data.tags || [],
    startTime: validatedFields.data.startTime,
    endTime: validatedFields.data.endTime,
    imageSrc: mainImageBuffer,
    extraImageSrcs: extraImagesBuffer,
    date: validatedFields.data.date,
    location:
      validatedFields.data.location || "California State University San Marcos",
    githubRepo: validatedFields.data.githubRepo || null,
    slidesURL: validatedFields.data.slidesURL || null,
    description: validatedFields.data.description,
    about: validatedFields.data.about?.body || null,
    attendeeIds: [],
    organizerIds: validatedFields.data.organizerIds,
    usersAttendedIds: [],
    updatedAt: createdAtDate,
    createdAt: createdAtDate,
    createdBy: user.userId as string,
  };

  await db.gDSCEvent.create({
    data: newGDSCEvent,
  });

  return { message: "Event successfully created" };
}
