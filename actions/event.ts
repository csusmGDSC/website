"use server";

/**
 * This file contains db actions for the event table
 */

import { GDSCEvent as GDSCEventPrisma } from "@prisma/client";
import { EVENT_TYPES } from "@/types/gdsc-event";
import { db } from "@/lib/db";
import { auth } from "@clerk/nextjs/server";
import { EventSchema } from "@/schemas";
import * as z from "zod";
import { LogIn } from "lucide-react";

/**
 * Retrieves a list of events from the database and converts them to JSON for client components.
 *
 * @return {GDSCEventPrisma[]} An array of events
 */
export async function getEvents(): Promise<string> {
  const events = await db.gDSCEvent.findMany();
  return JSON.stringify(events);
}

/**
 * Retrieves a list of events from the database without converting them to JSON for server components
 *
 * @return {GDSCEventPrisma[]} An array of events
 */
export async function getEventsWithoutJSON(): Promise<GDSCEventPrisma[]> {
  return await db.gDSCEvent.findMany();
}

/**
 * Retrieves a single event from the database by its ID.
 *
 * @param {string} id - The ID of the event to retrieve
 * @return {GDSCEventPrisma | null} The event with the specified ID, or null if the ID is invalid
 */
export async function getEventById(
  id: string
): Promise<GDSCEventPrisma | null> {
  // Check if the id is a valid ObjectId
  const objectIdRegex = /^[a-fA-F0-9]{24}$/;

  if (!objectIdRegex.test(id)) {
    return null;
  }

  return db.gDSCEvent.findUnique({ where: { id } });
}

/**
 * Creates a new event in the database.
 *
 * @param {FormData} values - A FormData object containing the event details.
 * @return {object} An object with a message or error property indicating the result of the operation.
 */
export async function createEvent(values: FormData) {
  const user = auth();

  if (!user || !user.userId) {
    return { error: "Unauthorized. Please login to create an event." };
  }

  if (user.sessionClaims?.metadata.role !== "ADMIN") {
    return { error: "Unauthorized. Only admins can create events." };
  }

  const imageCount: number = +(values.get("imageCount") as string) || 0;
  const aboutImages: File[] = [];

  for (let image = 0; image < imageCount; image++) {
    aboutImages.push(values.get(`aboutImages[${image}]`) as File);
  }

  // Getting the parsed values from the form to validate it.
  // For those confused, we always validate the schema client AND server side
  const parsedValues: z.infer<typeof EventSchema> = {
    eventName: values.get("eventName") as string,
    type: values.get("type") as (typeof EVENT_TYPES)[number],
    room: values.get("room") as string,
    startTime: values.get("startTime") as string,
    endTime: values.get("endTime") as string,
    date: new Date(values.get("date") as string),
    location: values.get("location") as string,
    description: values.get("description") as string,
    githubRepo: values.get("githubRepo") as string,
    slidesURL: values.get("slidesURL") as string,
    organizerIds: JSON.parse(values.get("organizerIds") as any) as string[],
    about: {
      body: JSON.parse(values.get("aboutBody") as string),
      images: aboutImages as File[],
    },
    ...(values.get("imageSrc") &&
      values.get("imageSrc") !== "" && {
        imageSrc: values.get("imageSrc") as File,
      }),
  };

  // Validate the parsed values, all used values after should be from validatedFields except for images
  const validatedFields = EventSchema.safeParse(parsedValues);
  if (!validatedFields.success) {
    console.log(
      "ERROR OCCURED IN CREATING EVENT: ",
      validatedFields.error.errors[0].message
    );
    return { error: validatedFields.error.errors[0].message };
  }

  // Convert files to buffer since mongodb can't save File types
  let mainImageBuffer: Buffer | null = null;
  let extraImagesBuffer: Buffer[] = [];
  if (parsedValues.imageSrc) {
    mainImageBuffer = Buffer.from(await parsedValues.imageSrc.arrayBuffer());
  }
  if (parsedValues.about?.images) {
    extraImagesBuffer = await Promise.all(
      parsedValues.about?.images.map(async (image) =>
        Buffer.from(await image.arrayBuffer())
      )
    );
  }

  const createdAtDate = new Date();

  // Using partial to ignore ID since it will be auto generated by mongoDB
  const newGDSCEvent: Required<Partial<Omit<GDSCEventPrisma, "id">>> = {
    name: validatedFields.data.eventName,
    type: validatedFields.data.type || "other",
    room: validatedFields.data.room,
    tags: validatedFields.data.tags || [],
    startTime: validatedFields.data.startTime,
    endTime: validatedFields.data.endTime,
    imageSrc: mainImageBuffer,
    extraImageSrcs: extraImagesBuffer,
    date: validatedFields.data.date,
    location:
      validatedFields.data.location || "California State University San Marcos",
    githubRepo: validatedFields.data.githubRepo || null,
    slidesURL: validatedFields.data.slidesURL || null,
    description: validatedFields.data.description,
    about: validatedFields.data.about?.body || null,
    attendeeIds: [],
    organizerIds: validatedFields.data.organizerIds,
    usersAttendedIds: [],
    updatedAt: createdAtDate,
    createdAt: createdAtDate,
    createdBy: user.userId as string,
  };

  await db.gDSCEvent.create({
    data: newGDSCEvent,
  });

  return { message: "Event successfully created" };
}
